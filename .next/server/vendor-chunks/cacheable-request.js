"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cacheable-request";
exports.ids = ["vendor-chunks/cacheable-request"];
exports.modules = {

/***/ "(rsc)/./node_modules/cacheable-request/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/cacheable-request/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CacheError: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_9__.CacheError),\n/* harmony export */   RequestError: () => (/* reexport safe */ _types_js__WEBPACK_IMPORTED_MODULE_9__.RequestError),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   onResponse: () => (/* binding */ onResponse)\n/* harmony export */ });\n/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:events */ \"node:events\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var normalize_url__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! normalize-url */ \"(rsc)/./node_modules/normalize-url/index.js\");\n/* harmony import */ var get_stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! get-stream */ \"(rsc)/./node_modules/get-stream/index.js\");\n/* harmony import */ var http_cache_semantics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! http-cache-semantics */ \"(rsc)/./node_modules/http-cache-semantics/index.js\");\n/* harmony import */ var responselike__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! responselike */ \"(rsc)/./node_modules/responselike/index.js\");\n/* harmony import */ var keyv__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! keyv */ \"(rsc)/./node_modules/keyv/src/index.js\");\n/* harmony import */ var mimic_response__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! mimic-response */ \"(rsc)/./node_modules/mimic-response/index.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./types.js */ \"(rsc)/./node_modules/cacheable-request/dist/types.js\");\n\n\n\n\n\n\n\n\n\n\n\nclass CacheableRequest {\n    constructor(cacheRequest, cacheAdapter) {\n        this.hooks = new Map();\n        this.request = () => (options, cb) => {\n            let url;\n            if (typeof options === 'string') {\n                url = normalizeUrlObject(node_url__WEBPACK_IMPORTED_MODULE_1__.parse(options));\n                options = {};\n            }\n            else if (options instanceof node_url__WEBPACK_IMPORTED_MODULE_1__.URL) {\n                url = normalizeUrlObject(node_url__WEBPACK_IMPORTED_MODULE_1__.parse(options.toString()));\n                options = {};\n            }\n            else {\n                const [pathname, ...searchParts] = (options.path ?? '').split('?');\n                const search = searchParts.length > 0\n                    ? `?${searchParts.join('?')}`\n                    : '';\n                url = normalizeUrlObject({ ...options, pathname, search });\n            }\n            options = {\n                headers: {},\n                method: 'GET',\n                cache: true,\n                strictTtl: false,\n                automaticFailover: false,\n                ...options,\n                ...urlObjectToRequestOptions(url),\n            };\n            options.headers = Object.fromEntries(entries(options.headers).map(([key, value]) => [key.toLowerCase(), value]));\n            const ee = new node_events__WEBPACK_IMPORTED_MODULE_0__();\n            const normalizedUrlString = (0,normalize_url__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(node_url__WEBPACK_IMPORTED_MODULE_1__.format(url), {\n                stripWWW: false,\n                removeTrailingSlash: false,\n                stripAuthentication: false,\n            });\n            let key = `${options.method}:${normalizedUrlString}`;\n            // POST, PATCH, and PUT requests may be cached, depending on the response\n            // cache-control headers. As a result, the body of the request should be\n            // added to the cache key in order to avoid collisions.\n            if (options.body && options.method !== undefined && ['POST', 'PATCH', 'PUT'].includes(options.method)) {\n                if (options.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable) {\n                    // Streamed bodies should completely skip the cache because they may\n                    // or may not be hashable and in either case the stream would need to\n                    // close before the cache key could be generated.\n                    options.cache = false;\n                }\n                else {\n                    key += `:${node_crypto__WEBPACK_IMPORTED_MODULE_2__.createHash('md5').update(options.body).digest('hex')}`;\n                }\n            }\n            let revalidate = false;\n            let madeRequest = false;\n            const makeRequest = (options_) => {\n                madeRequest = true;\n                let requestErrored = false;\n                let requestErrorCallback = () => { };\n                const requestErrorPromise = new Promise(resolve => {\n                    requestErrorCallback = () => {\n                        if (!requestErrored) {\n                            requestErrored = true;\n                            resolve();\n                        }\n                    };\n                });\n                const handler = async (response) => {\n                    if (revalidate) {\n                        response.status = response.statusCode;\n                        const revalidatedPolicy = http_cache_semantics__WEBPACK_IMPORTED_MODULE_5__.fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);\n                        if (!revalidatedPolicy.modified) {\n                            response.resume();\n                            await new Promise(resolve => {\n                                // Skipping 'error' handler cause 'error' event should't be emitted for 304 response\n                                response\n                                    .once('end', resolve);\n                            });\n                            const headers = convertHeaders(revalidatedPolicy.policy.responseHeaders());\n                            response = new responselike__WEBPACK_IMPORTED_MODULE_6__[\"default\"]({ statusCode: revalidate.statusCode, headers, body: revalidate.body, url: revalidate.url });\n                            response.cachePolicy = revalidatedPolicy.policy;\n                            response.fromCache = true;\n                        }\n                    }\n                    if (!response.fromCache) {\n                        response.cachePolicy = new http_cache_semantics__WEBPACK_IMPORTED_MODULE_5__(options_, response, options_);\n                        response.fromCache = false;\n                    }\n                    let clonedResponse;\n                    if (options_.cache && response.cachePolicy.storable()) {\n                        clonedResponse = cloneResponse(response);\n                        (async () => {\n                            try {\n                                const bodyPromise = get_stream__WEBPACK_IMPORTED_MODULE_4__.buffer(response);\n                                await Promise.race([\n                                    requestErrorPromise,\n                                    new Promise(resolve => response.once('end', resolve)),\n                                    new Promise(resolve => response.once('close', resolve)), // eslint-disable-line no-promise-executor-return\n                                ]);\n                                const body = await bodyPromise;\n                                let value = {\n                                    url: response.url,\n                                    statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,\n                                    body,\n                                    cachePolicy: response.cachePolicy.toObject(),\n                                };\n                                let ttl = options_.strictTtl ? response.cachePolicy.timeToLive() : undefined;\n                                if (options_.maxTtl) {\n                                    ttl = ttl ? Math.min(ttl, options_.maxTtl) : options_.maxTtl;\n                                }\n                                if (this.hooks.size > 0) {\n                                    /* eslint-disable no-await-in-loop */\n                                    for (const key_ of this.hooks.keys()) {\n                                        value = await this.runHook(key_, value, response);\n                                    }\n                                    /* eslint-enable no-await-in-loop */\n                                }\n                                await this.cache.set(key, value, ttl);\n                            }\n                            catch (error) {\n                                ee.emit('error', new _types_js__WEBPACK_IMPORTED_MODULE_9__.CacheError(error));\n                            }\n                        })();\n                    }\n                    else if (options_.cache && revalidate) {\n                        (async () => {\n                            try {\n                                await this.cache.delete(key);\n                            }\n                            catch (error) {\n                                ee.emit('error', new _types_js__WEBPACK_IMPORTED_MODULE_9__.CacheError(error));\n                            }\n                        })();\n                    }\n                    ee.emit('response', clonedResponse ?? response);\n                    if (typeof cb === 'function') {\n                        cb(clonedResponse ?? response);\n                    }\n                };\n                try {\n                    const request_ = this.cacheRequest(options_, handler);\n                    request_.once('error', requestErrorCallback);\n                    request_.once('abort', requestErrorCallback);\n                    request_.once('destroy', requestErrorCallback);\n                    ee.emit('request', request_);\n                }\n                catch (error) {\n                    ee.emit('error', new _types_js__WEBPACK_IMPORTED_MODULE_9__.RequestError(error));\n                }\n            };\n            (async () => {\n                const get = async (options_) => {\n                    await Promise.resolve();\n                    const cacheEntry = options_.cache ? await this.cache.get(key) : undefined;\n                    if (cacheEntry === undefined && !options_.forceRefresh) {\n                        makeRequest(options_);\n                        return;\n                    }\n                    const policy = http_cache_semantics__WEBPACK_IMPORTED_MODULE_5__.fromObject(cacheEntry.cachePolicy);\n                    if (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {\n                        const headers = convertHeaders(policy.responseHeaders());\n                        const response = new responselike__WEBPACK_IMPORTED_MODULE_6__[\"default\"]({ statusCode: cacheEntry.statusCode, headers, body: cacheEntry.body, url: cacheEntry.url });\n                        response.cachePolicy = policy;\n                        response.fromCache = true;\n                        ee.emit('response', response);\n                        if (typeof cb === 'function') {\n                            cb(response);\n                        }\n                    }\n                    else if (policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh) {\n                        await this.cache.delete(key);\n                        options_.headers = policy.revalidationHeaders(options_);\n                        makeRequest(options_);\n                    }\n                    else {\n                        revalidate = cacheEntry;\n                        options_.headers = policy.revalidationHeaders(options_);\n                        makeRequest(options_);\n                    }\n                };\n                const errorHandler = (error) => ee.emit('error', new _types_js__WEBPACK_IMPORTED_MODULE_9__.CacheError(error));\n                if (this.cache instanceof keyv__WEBPACK_IMPORTED_MODULE_7__) {\n                    const cachek = this.cache;\n                    cachek.once('error', errorHandler);\n                    ee.on('error', () => cachek.removeListener('error', errorHandler));\n                    ee.on('response', () => cachek.removeListener('error', errorHandler));\n                }\n                try {\n                    await get(options);\n                }\n                catch (error) {\n                    if (options.automaticFailover && !madeRequest) {\n                        makeRequest(options);\n                    }\n                    ee.emit('error', new _types_js__WEBPACK_IMPORTED_MODULE_9__.CacheError(error));\n                }\n            })();\n            return ee;\n        };\n        this.addHook = (name, fn) => {\n            if (!this.hooks.has(name)) {\n                this.hooks.set(name, fn);\n            }\n        };\n        this.removeHook = (name) => this.hooks.delete(name);\n        this.getHook = (name) => this.hooks.get(name);\n        this.runHook = async (name, ...args) => this.hooks.get(name)?.(...args);\n        if (cacheAdapter instanceof keyv__WEBPACK_IMPORTED_MODULE_7__) {\n            this.cache = cacheAdapter;\n        }\n        else if (typeof cacheAdapter === 'string') {\n            this.cache = new keyv__WEBPACK_IMPORTED_MODULE_7__({\n                uri: cacheAdapter,\n                namespace: 'cacheable-request',\n            });\n        }\n        else {\n            this.cache = new keyv__WEBPACK_IMPORTED_MODULE_7__({\n                store: cacheAdapter,\n                namespace: 'cacheable-request',\n            });\n        }\n        this.request = this.request.bind(this);\n        this.cacheRequest = cacheRequest;\n    }\n}\nconst entries = Object.entries;\nconst cloneResponse = (response) => {\n    const clone = new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough({ autoDestroy: false });\n    (0,mimic_response__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(response, clone);\n    return response.pipe(clone);\n};\nconst urlObjectToRequestOptions = (url) => {\n    const options = { ...url };\n    options.path = `${url.pathname || '/'}${url.search || ''}`;\n    delete options.pathname;\n    delete options.search;\n    return options;\n};\nconst normalizeUrlObject = (url) => \n// If url was parsed by url.parse or new URL:\n// - hostname will be set\n// - host will be hostname[:port]\n// - port will be set if it was explicit in the parsed string\n// Otherwise, url was from request options:\n// - hostname or host may be set\n// - host shall not have port encoded\n({\n    protocol: url.protocol,\n    auth: url.auth,\n    hostname: url.hostname || url.host || 'localhost',\n    port: url.port,\n    pathname: url.pathname,\n    search: url.search,\n});\nconst convertHeaders = (headers) => {\n    const result = [];\n    for (const name of Object.keys(headers)) {\n        result[name.toLowerCase()] = headers[name];\n    }\n    return result;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CacheableRequest);\n\nconst onResponse = 'onResponse';\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2FjaGVhYmxlLXJlcXVlc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDVDtBQUNHO0FBQ3NDO0FBQzlCO0FBQ047QUFDWTtBQUNYO0FBQ1o7QUFDbUI7QUFDVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMkNBQVk7QUFDckQ7QUFDQTtBQUNBLHdDQUF3Qyx5Q0FBVTtBQUNsRCx5Q0FBeUMsMkNBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQSwyQ0FBMkMsOEJBQThCO0FBQ3pFO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3Q0FBWTtBQUN2Qyx3Q0FBd0MsMERBQVksQ0FBQyw0Q0FBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IseUJBQXlCLGVBQWUsR0FBRyxvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaURBQWU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFpQiwyQ0FBMkM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw0REFBc0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsMkNBQTJDLG9EQUFRLEdBQUcsd0ZBQXdGO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaURBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsOENBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaURBQVU7QUFDL0Q7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaURBQVU7QUFDL0Q7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtREFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw0REFBc0I7QUFDekQ7QUFDQTtBQUNBLDZDQUE2QyxvREFBUSxHQUFHLHdGQUF3RjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsaURBQVU7QUFDL0UsMENBQTBDLGlDQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpREFBVTtBQUNuRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQ0FBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUNBQUk7QUFDakM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkJBQTZCLGlDQUFJO0FBQ2pDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQWlCLEdBQUcsb0JBQW9CO0FBQzlELElBQUksMERBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQixvQkFBb0IsRUFBRSxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxnQkFBZ0IsRUFBQztBQUNMO0FBQ3BCO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kbmZtLWJvdC8uL25vZGVfbW9kdWxlcy9jYWNoZWFibGUtcmVxdWVzdC9kaXN0L2luZGV4LmpzPzAzZWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdub2RlOmV2ZW50cyc7XG5pbXBvcnQgdXJsTGliIGZyb20gJ25vZGU6dXJsJztcbmltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuaW1wb3J0IHN0cmVhbSwgeyBQYXNzVGhyb3VnaCBhcyBQYXNzVGhyb3VnaFN0cmVhbSB9IGZyb20gJ25vZGU6c3RyZWFtJztcbmltcG9ydCBub3JtYWxpemVVcmwgZnJvbSAnbm9ybWFsaXplLXVybCc7XG5pbXBvcnQgZ2V0U3RyZWFtIGZyb20gJ2dldC1zdHJlYW0nO1xuaW1wb3J0IENhY2hlUG9saWN5IGZyb20gJ2h0dHAtY2FjaGUtc2VtYW50aWNzJztcbmltcG9ydCBSZXNwb25zZSBmcm9tICdyZXNwb25zZWxpa2UnO1xuaW1wb3J0IEtleXYgZnJvbSAna2V5dic7XG5pbXBvcnQgbWltaWNSZXNwb25zZSBmcm9tICdtaW1pYy1yZXNwb25zZSc7XG5pbXBvcnQgeyBDYWNoZUVycm9yLCBSZXF1ZXN0RXJyb3IgfSBmcm9tICcuL3R5cGVzLmpzJztcbmNsYXNzIENhY2hlYWJsZVJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlUmVxdWVzdCwgY2FjaGVBZGFwdGVyKSB7XG4gICAgICAgIHRoaXMuaG9va3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9ICgpID0+IChvcHRpb25zLCBjYikgPT4ge1xuICAgICAgICAgICAgbGV0IHVybDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBub3JtYWxpemVVcmxPYmplY3QodXJsTGliLnBhcnNlKG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zIGluc3RhbmNlb2YgdXJsTGliLlVSTCkge1xuICAgICAgICAgICAgICAgIHVybCA9IG5vcm1hbGl6ZVVybE9iamVjdCh1cmxMaWIucGFyc2Uob3B0aW9ucy50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3BhdGhuYW1lLCAuLi5zZWFyY2hQYXJ0c10gPSAob3B0aW9ucy5wYXRoID8/ICcnKS5zcGxpdCgnPycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlYXJjaCA9IHNlYXJjaFBhcnRzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyBgPyR7c2VhcmNoUGFydHMuam9pbignPycpfWBcbiAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICB1cmwgPSBub3JtYWxpemVVcmxPYmplY3QoeyAuLi5vcHRpb25zLCBwYXRobmFtZSwgc2VhcmNoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0cmljdFR0bDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXV0b21hdGljRmFpbG92ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgLi4udXJsT2JqZWN0VG9SZXF1ZXN0T3B0aW9ucyh1cmwpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5mcm9tRW50cmllcyhlbnRyaWVzKG9wdGlvbnMuaGVhZGVycykubWFwKChba2V5LCB2YWx1ZV0pID0+IFtrZXkudG9Mb3dlckNhc2UoKSwgdmFsdWVdKSk7XG4gICAgICAgICAgICBjb25zdCBlZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRVcmxTdHJpbmcgPSBub3JtYWxpemVVcmwodXJsTGliLmZvcm1hdCh1cmwpLCB7XG4gICAgICAgICAgICAgICAgc3RyaXBXV1c6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbW92ZVRyYWlsaW5nU2xhc2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0cmlwQXV0aGVudGljYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQga2V5ID0gYCR7b3B0aW9ucy5tZXRob2R9OiR7bm9ybWFsaXplZFVybFN0cmluZ31gO1xuICAgICAgICAgICAgLy8gUE9TVCwgUEFUQ0gsIGFuZCBQVVQgcmVxdWVzdHMgbWF5IGJlIGNhY2hlZCwgZGVwZW5kaW5nIG9uIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgLy8gY2FjaGUtY29udHJvbCBoZWFkZXJzLiBBcyBhIHJlc3VsdCwgdGhlIGJvZHkgb2YgdGhlIHJlcXVlc3Qgc2hvdWxkIGJlXG4gICAgICAgICAgICAvLyBhZGRlZCB0byB0aGUgY2FjaGUga2V5IGluIG9yZGVyIHRvIGF2b2lkIGNvbGxpc2lvbnMuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ib2R5ICYmIG9wdGlvbnMubWV0aG9kICE9PSB1bmRlZmluZWQgJiYgWydQT1NUJywgJ1BBVENIJywgJ1BVVCddLmluY2x1ZGVzKG9wdGlvbnMubWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBzdHJlYW0uUmVhZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyZWFtZWQgYm9kaWVzIHNob3VsZCBjb21wbGV0ZWx5IHNraXAgdGhlIGNhY2hlIGJlY2F1c2UgdGhleSBtYXlcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgbWF5IG5vdCBiZSBoYXNoYWJsZSBhbmQgaW4gZWl0aGVyIGNhc2UgdGhlIHN0cmVhbSB3b3VsZCBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsb3NlIGJlZm9yZSB0aGUgY2FjaGUga2V5IGNvdWxkIGJlIGdlbmVyYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jYWNoZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ICs9IGA6JHtjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKG9wdGlvbnMuYm9keSkuZGlnZXN0KCdoZXgnKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXZhbGlkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbWFkZVJlcXVlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG1ha2VSZXF1ZXN0ID0gKG9wdGlvbnNfKSA9PiB7XG4gICAgICAgICAgICAgICAgbWFkZVJlcXVlc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0RXJyb3JlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0RXJyb3JDYWxsYmFjayA9ICgpID0+IHsgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0RXJyb3JQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RFcnJvckNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0RXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RFcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldmFsaWRhdGVkUG9saWN5ID0gQ2FjaGVQb2xpY3kuZnJvbU9iamVjdChyZXZhbGlkYXRlLmNhY2hlUG9saWN5KS5yZXZhbGlkYXRlZFBvbGljeShvcHRpb25zXywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXZhbGlkYXRlZFBvbGljeS5tb2RpZmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwcGluZyAnZXJyb3InIGhhbmRsZXIgY2F1c2UgJ2Vycm9yJyBldmVudCBzaG91bGQndCBiZSBlbWl0dGVkIGZvciAzMDQgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbmNlKCdlbmQnLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gY29udmVydEhlYWRlcnMocmV2YWxpZGF0ZWRQb2xpY3kucG9saWN5LnJlc3BvbnNlSGVhZGVycygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IG5ldyBSZXNwb25zZSh7IHN0YXR1c0NvZGU6IHJldmFsaWRhdGUuc3RhdHVzQ29kZSwgaGVhZGVycywgYm9keTogcmV2YWxpZGF0ZS5ib2R5LCB1cmw6IHJldmFsaWRhdGUudXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmNhY2hlUG9saWN5ID0gcmV2YWxpZGF0ZWRQb2xpY3kucG9saWN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmZyb21DYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5mcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmNhY2hlUG9saWN5ID0gbmV3IENhY2hlUG9saWN5KG9wdGlvbnNfLCByZXNwb25zZSwgb3B0aW9uc18pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZnJvbUNhY2hlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNsb25lZFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uc18uY2FjaGUgJiYgcmVzcG9uc2UuY2FjaGVQb2xpY3kuc3RvcmFibGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkUmVzcG9uc2UgPSBjbG9uZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keVByb21pc2UgPSBnZXRTdHJlYW0uYnVmZmVyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RFcnJvclByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHJlc3BvbnNlLm9uY2UoJ2VuZCcsIHJlc29sdmUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gcmVzcG9uc2Uub25jZSgnY2xvc2UnLCByZXNvbHZlKSksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvbWlzZS1leGVjdXRvci1yZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCBib2R5UHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5mcm9tQ2FjaGUgPyByZXZhbGlkYXRlLnN0YXR1c0NvZGUgOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlUG9saWN5OiByZXNwb25zZS5jYWNoZVBvbGljeS50b09iamVjdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHRsID0gb3B0aW9uc18uc3RyaWN0VHRsID8gcmVzcG9uc2UuY2FjaGVQb2xpY3kudGltZVRvTGl2ZSgpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9uc18ubWF4VHRsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dGwgPSB0dGwgPyBNYXRoLm1pbih0dGwsIG9wdGlvbnNfLm1heFR0bCkgOiBvcHRpb25zXy5tYXhUdGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaG9va3Muc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWF3YWl0LWluLWxvb3AgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5XyBvZiB0aGlzLmhvb2tzLmtleXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXdhaXQgdGhpcy5ydW5Ib29rKGtleV8sIHZhbHVlLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWF3YWl0LWluLWxvb3AgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlLCB0dGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWUuZW1pdCgnZXJyb3InLCBuZXcgQ2FjaGVFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9uc18uY2FjaGUgJiYgcmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWUuZW1pdCgnZXJyb3InLCBuZXcgQ2FjaGVFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWUuZW1pdCgncmVzcG9uc2UnLCBjbG9uZWRSZXNwb25zZSA/PyByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKGNsb25lZFJlc3BvbnNlID8/IHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdF8gPSB0aGlzLmNhY2hlUmVxdWVzdChvcHRpb25zXywgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RfLm9uY2UoJ2Vycm9yJywgcmVxdWVzdEVycm9yQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Xy5vbmNlKCdhYm9ydCcsIHJlcXVlc3RFcnJvckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdF8ub25jZSgnZGVzdHJveScsIHJlcXVlc3RFcnJvckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgZWUuZW1pdCgncmVxdWVzdCcsIHJlcXVlc3RfKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVlLmVtaXQoJ2Vycm9yJywgbmV3IFJlcXVlc3RFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldCA9IGFzeW5jIChvcHRpb25zXykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IG9wdGlvbnNfLmNhY2hlID8gYXdhaXQgdGhpcy5jYWNoZS5nZXQoa2V5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkgPT09IHVuZGVmaW5lZCAmJiAhb3B0aW9uc18uZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUmVxdWVzdChvcHRpb25zXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9saWN5ID0gQ2FjaGVQb2xpY3kuZnJvbU9iamVjdChjYWNoZUVudHJ5LmNhY2hlUG9saWN5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbGljeS5zYXRpc2ZpZXNXaXRob3V0UmV2YWxpZGF0aW9uKG9wdGlvbnNfKSAmJiAhb3B0aW9uc18uZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gY29udmVydEhlYWRlcnMocG9saWN5LnJlc3BvbnNlSGVhZGVycygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHsgc3RhdHVzQ29kZTogY2FjaGVFbnRyeS5zdGF0dXNDb2RlLCBoZWFkZXJzLCBib2R5OiBjYWNoZUVudHJ5LmJvZHksIHVybDogY2FjaGVFbnRyeS51cmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5jYWNoZVBvbGljeSA9IHBvbGljeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmZyb21DYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZS5lbWl0KCdyZXNwb25zZScsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9saWN5LnNhdGlzZmllc1dpdGhvdXRSZXZhbGlkYXRpb24ob3B0aW9uc18pICYmIERhdGUubm93KCkgPj0gcG9saWN5LnRpbWVUb0xpdmUoKSAmJiBvcHRpb25zXy5mb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zXy5oZWFkZXJzID0gcG9saWN5LnJldmFsaWRhdGlvbkhlYWRlcnMob3B0aW9uc18pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcXVlc3Qob3B0aW9uc18pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSA9IGNhY2hlRW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zXy5oZWFkZXJzID0gcG9saWN5LnJldmFsaWRhdGlvbkhlYWRlcnMob3B0aW9uc18pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcXVlc3Qob3B0aW9uc18pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoZXJyb3IpID0+IGVlLmVtaXQoJ2Vycm9yJywgbmV3IENhY2hlRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWNoZSBpbnN0YW5jZW9mIEtleXYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVrID0gdGhpcy5jYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVrLm9uY2UoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZWUub24oJ2Vycm9yJywgKCkgPT4gY2FjaGVrLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcikpO1xuICAgICAgICAgICAgICAgICAgICBlZS5vbigncmVzcG9uc2UnLCAoKSA9PiBjYWNoZWsucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JIYW5kbGVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGdldChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmF1dG9tYXRpY0ZhaWxvdmVyICYmICFtYWRlUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWUuZW1pdCgnZXJyb3InLCBuZXcgQ2FjaGVFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICByZXR1cm4gZWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSG9vayA9IChuYW1lLCBmbikgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhvb2tzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaG9va3Muc2V0KG5hbWUsIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW1vdmVIb29rID0gKG5hbWUpID0+IHRoaXMuaG9va3MuZGVsZXRlKG5hbWUpO1xuICAgICAgICB0aGlzLmdldEhvb2sgPSAobmFtZSkgPT4gdGhpcy5ob29rcy5nZXQobmFtZSk7XG4gICAgICAgIHRoaXMucnVuSG9vayA9IGFzeW5jIChuYW1lLCAuLi5hcmdzKSA9PiB0aGlzLmhvb2tzLmdldChuYW1lKT8uKC4uLmFyZ3MpO1xuICAgICAgICBpZiAoY2FjaGVBZGFwdGVyIGluc3RhbmNlb2YgS2V5dikge1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlQWRhcHRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2FjaGVBZGFwdGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBLZXl2KHtcbiAgICAgICAgICAgICAgICB1cmk6IGNhY2hlQWRhcHRlcixcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6ICdjYWNoZWFibGUtcmVxdWVzdCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgS2V5dih7XG4gICAgICAgICAgICAgICAgc3RvcmU6IGNhY2hlQWRhcHRlcixcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6ICdjYWNoZWFibGUtcmVxdWVzdCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWNoZVJlcXVlc3QgPSBjYWNoZVJlcXVlc3Q7XG4gICAgfVxufVxuY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzO1xuY29uc3QgY2xvbmVSZXNwb25zZSA9IChyZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IFBhc3NUaHJvdWdoU3RyZWFtKHsgYXV0b0Rlc3Ryb3k6IGZhbHNlIH0pO1xuICAgIG1pbWljUmVzcG9uc2UocmVzcG9uc2UsIGNsb25lKTtcbiAgICByZXR1cm4gcmVzcG9uc2UucGlwZShjbG9uZSk7XG59O1xuY29uc3QgdXJsT2JqZWN0VG9SZXF1ZXN0T3B0aW9ucyA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0geyAuLi51cmwgfTtcbiAgICBvcHRpb25zLnBhdGggPSBgJHt1cmwucGF0aG5hbWUgfHwgJy8nfSR7dXJsLnNlYXJjaCB8fCAnJ31gO1xuICAgIGRlbGV0ZSBvcHRpb25zLnBhdGhuYW1lO1xuICAgIGRlbGV0ZSBvcHRpb25zLnNlYXJjaDtcbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5jb25zdCBub3JtYWxpemVVcmxPYmplY3QgPSAodXJsKSA9PiBcbi8vIElmIHVybCB3YXMgcGFyc2VkIGJ5IHVybC5wYXJzZSBvciBuZXcgVVJMOlxuLy8gLSBob3N0bmFtZSB3aWxsIGJlIHNldFxuLy8gLSBob3N0IHdpbGwgYmUgaG9zdG5hbWVbOnBvcnRdXG4vLyAtIHBvcnQgd2lsbCBiZSBzZXQgaWYgaXQgd2FzIGV4cGxpY2l0IGluIHRoZSBwYXJzZWQgc3RyaW5nXG4vLyBPdGhlcndpc2UsIHVybCB3YXMgZnJvbSByZXF1ZXN0IG9wdGlvbnM6XG4vLyAtIGhvc3RuYW1lIG9yIGhvc3QgbWF5IGJlIHNldFxuLy8gLSBob3N0IHNoYWxsIG5vdCBoYXZlIHBvcnQgZW5jb2RlZFxuKHtcbiAgICBwcm90b2NvbDogdXJsLnByb3RvY29sLFxuICAgIGF1dGg6IHVybC5hdXRoLFxuICAgIGhvc3RuYW1lOiB1cmwuaG9zdG5hbWUgfHwgdXJsLmhvc3QgfHwgJ2xvY2FsaG9zdCcsXG4gICAgcG9ydDogdXJsLnBvcnQsXG4gICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG59KTtcbmNvbnN0IGNvbnZlcnRIZWFkZXJzID0gKGhlYWRlcnMpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgcmVzdWx0W25hbWUudG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydCBkZWZhdWx0IENhY2hlYWJsZVJlcXVlc3Q7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzLmpzJztcbmV4cG9ydCBjb25zdCBvblJlc3BvbnNlID0gJ29uUmVzcG9uc2UnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cacheable-request/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/cacheable-request/dist/types.js":
/*!******************************************************!*\
  !*** ./node_modules/cacheable-request/dist/types.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CacheError: () => (/* binding */ CacheError),\n/* harmony export */   RequestError: () => (/* binding */ RequestError)\n/* harmony export */ });\n// Type definitions for cacheable-request 6.0\n// Project: https://github.com/lukechilds/cacheable-request#readme\n// Definitions by: BendingBender <https://github.com/BendingBender>\n//                 Paul Melnikow <https://github.com/paulmelnikow>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\nclass RequestError extends Error {\n    constructor(error) {\n        super(error.message);\n        Object.assign(this, error);\n    }\n}\nclass CacheError extends Error {\n    constructor(error) {\n        super(error.message);\n        Object.assign(this, error);\n    }\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2FjaGVhYmxlLXJlcXVlc3QvZGlzdC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZG5mbS1ib3QvLi9ub2RlX21vZHVsZXMvY2FjaGVhYmxlLXJlcXVlc3QvZGlzdC90eXBlcy5qcz9jMzQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGNhY2hlYWJsZS1yZXF1ZXN0IDYuMFxuLy8gUHJvamVjdDogaHR0cHM6Ly9naXRodWIuY29tL2x1a2VjaGlsZHMvY2FjaGVhYmxlLXJlcXVlc3QjcmVhZG1lXG4vLyBEZWZpbml0aW9ucyBieTogQmVuZGluZ0JlbmRlciA8aHR0cHM6Ly9naXRodWIuY29tL0JlbmRpbmdCZW5kZXI+XG4vLyAgICAgICAgICAgICAgICAgUGF1bCBNZWxuaWtvdyA8aHR0cHM6Ly9naXRodWIuY29tL3BhdWxtZWxuaWtvdz5cbi8vIERlZmluaXRpb25zOiBodHRwczovL2dpdGh1Yi5jb20vRGVmaW5pdGVseVR5cGVkL0RlZmluaXRlbHlUeXBlZFxuLy8gVHlwZVNjcmlwdCBWZXJzaW9uOiAyLjNcbmV4cG9ydCBjbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgZXJyb3IpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWNoZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGVycm9yKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/cacheable-request/dist/types.js\n");

/***/ })

};
;